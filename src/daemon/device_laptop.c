#include "command.h"
#include "device.h"
#include "devnode.h"
#include "input.h"
#include "usb.h"

// CMD BASE CONSTANTS
const uchar CMD_TOTAL_BYTES = 192;
const uchar CMD_HEADER_BYTES = 4;
const uchar CMD_ENTRY_BYTES = 4;
const uchar CMD_TOTAL_ENTRIES = 47; // (CMD_TOTAL_BYTES - CMD_HEADER_BYTES) / CMD_ENTRY_BYTES

// Small helper to limit entries per command
uchar limit_entries(uchar count) {
    if (count > CMD_TOTAL_ENTRIES)
        return CMD_TOTAL_ENTRIES;

    return count;
}

// CMD_RGB_KEYBORD (0xa1): 0x01 -> 0x8f (?)
const uchar CMD_RGB_KEYBORD = 0xa1;

const uchar CMD_RGB_KEYBORD_IDS[5][47] = {
    { 0x14, 0x9d, 0x9b, 0x9f, 0x9c, 0xa1, 0x26, 0x28, 0x27, 0x67, 0x29, 0x4f, 0xa7, 0x51, 0x50, 0x79, 0x7c, 0x7b, 0x90, 0x8e, 0xa3, 0x92, 0xa5, 0x01, 0x03, 0x02, 0x05, 0x04, 0x07, 0x06, 0x09, 0x08, 0x0b, 0x0a, 0x16, 0x0c, 0x2d, 0x2c, 0x2f, 0x2e, 0x31, 0x30, 0x33, 0x32, 0x35, 0x34, 0x40 },
    { 0x36, 0x43, 0x42, 0x45, 0x44, 0x47, 0x46, 0x49, 0x48, 0x4b, 0x4a, 0x55, 0x4c, 0x6e, 0x6d, 0x59, 0x58, 0x71, 0x5a, 0x5b, 0x72, 0x5d, 0x5c, 0x6a, 0x5f, 0x82, 0x81, 0x6f, 0x83, 0x87, 0x70, 0x73, 0x88, 0x75, 0x74, 0x7f, 0x76, 0x97, 0x96, 0x80, 0x98, 0x9a, 0x0d, 0x0f, 0x0e, 0x13, 0x11 },
    { 0x4d, 0x4e, 0x78, 0x37, 0x3a, 0x12, 0x10, 0x8d, 0x00 },
    { 0x9e, 0xa0, 0x3b, 0x68, 0x64, 0xa8, 0x66, 0x65, 0x7a, 0x7d, 0x91, 0x8f, 0xa4, 0x93, 0xa6, 0x2b, 0x18, 0x17, 0x1a, 0x19, 0x1c, 0x1b, 0x1e, 0x1d, 0x20, 0x1f, 0x21, 0x56, 0x61, 0x5e, 0x60, 0x6c, 0x8a, 0x89, 0x8b, 0x99, 0x62, 0x77, 0x22, 0xa2, 0x00 },
    { 0x57, 0x00 },
};

const uchar CMD_RGB_KEYBORD_COUNTS[5] = { 0x2f, 0x2f, 0x08, 0x20, 0x01 };

// CMD_RGB_LOGO (0xa2): 0x01 -> 0x0d
const uchar CMD_RGB_LOGO = 0xa2;

const uchar CMD_RGB_LOGO_COUNT = 0x0d;

// CMD_RGB_CASE1 (0xa3)
//   Left: 0x01 -> 0x1b
//   Right: 0x1c -> 0x36
//   Top Right: 0x37 -> 0x50
//   Top Left: 0x51 -> 0x6a
const uchar CMD_RGB_CASE1 = 0xa3;

const uchar CMD_RGB_CASE1_IDS[] = {
    0x2e, 0x2d, 0x30, 0x2f, 0x32, 0x31, 0x34, 0x33, 0x36, 0x35,
    0x4f, 0x50, 0x4d, 0x4e, 0x4b, 0x4c, 0x49, 0x4a, 0x47, 0x48, 0x45, 0x46, 0x43, 0x44, 0x41, 0x42, 0x3f, 0x40, 0x3d, 0x3e, 0x3b, 0x3c, 0x39, 0x3a, 0x37, 0x38,
    0x52, 0x51, 0x54, 0x53, 0x56, 0x55, 0x58, 0x57, 0x5a, 0x59, 0x5c,
    0x5b, 0x5e, 0x5d, 0x60, 0x5f, 0x62, 0x61, 0x64, 0x63, 0x66, 0x65, 0x68, 0x67, 0x6a, 0x69,
    0x1c, 0x1e, 0x1d, 0x20, 0x1f, 0x22, 0x21, 0x24, 0x23, 0x26, 0x25, 0x28, 0x27, 0x2a, 0x29, 0x2c, 0x2b,
    0x0b, 0x0c, 0x09, 0x0a, 0x07, 0x08, 0x05, 0x06, 0x03, 0x04, 0x01, 0x02, 0x1b, 0x19, 0x1a,
    0x17, 0x18, 0x15, 0x16, 0x13, 0x14, 0x11, 0x12, 0x0f, 0x10, 0x0d, 0x0e,
};

const uchar CMD_RGB_CASE1_COUNT = sizeof(CMD_RGB_CASE1_IDS);

// CMD_RGB_CASE2 (0xa4)
//   Left: 0x01 -> 0x15
//   Bottom: 0x16 -> 0x4e
//   Right: 0x4f -> 0x63
const uchar CMD_RGB_CASE2 = 0xa4;

const uchar CMD_RGB_CASE2_IDS[] = {
    0x36, 0x35, 0x38, 0x37, 0x3a, 0x39, 0x3c, 0x3b, 0x3e, 0x3d, 0x40, 0x3f, 0x42, 0x41, 0x44, 0x43, 0x46, 0x45, 0x48, 0x47, 0x4a, 0x49, 0x4c, 0x4b, 0x4e, 0x4d,
    0x50, 0x4f, 0x52, 0x51, 0x54, 0x53, 0x56, 0x55, 0x58, 0x57, 0x5a, 0x59, 0x5c, 0x5b, 0x5e, 0x5d, 0x60, 0x5f, 0x62, 0x61, 0x63,
    0x02, 0x01, 0x04, 0x03, 0x06, 0x05, 0x08, 0x07, 0x0a, 0x09, 0x0c, 0x0b, 0x0e, 0x0d, 0x10, 0x0f, 0x12, 0x11, 0x14, 0x13,
    0x16, 0x15, 0x18, 0x17, 0x1a, 0x18, 0x1c, 0x1b, 0x1e, 0x1d, 0x20, 0x1f, 0x22, 0x21, 0x24, 0x23, 0x26, 0x25, 0x28, 0x27, 0x2a, 0x29, 0x2c, 0x2b, 0x2e, 0x2d, 0x30,
    0x2f, 0x32, 0x31, 0x34, 0x33,
};

const uchar CMD_RGB_CASE2_COUNT = sizeof(CMD_RGB_CASE2_IDS);

// TODO: Unused, might be needed for Y730
const uchar CMD_RGB_KEYBORD_Y370_IDS[3][47] = {
    { 0xc3, 0xc6, 0xc5, 0x1d, 0x1c, 0x2b, 0x0d, 0x0f, 0x4c, 0x39, 0x53, 0x40, 0x54, 0x4f, 0x3d, 0x3e, 0x7b, 0x2c, 0x29, 0x2e, 0x30, 0x2f, 0x32, 0x31, 0x34, 0x33, 0x36, 0x35, 0x3a, 0x37, 0x3c, 0x7f, 0x18, 0x17, 0x1a, 0x19, 0x1e, 0x1b, 0x20, 0x1f, 0x22, 0x21, 0x24, 0x23, 0x26, 0x25, 0x28 },
    { 0x27, 0x05, 0x04, 0x07, 0x06, 0x09, 0x08, 0x3b, 0x0b, 0x0a, 0x10, 0x0c, 0x12, 0x11, 0x14, 0x13, 0x16, 0x15, 0x6e, 0x71, 0x70, 0x73, 0x72, 0x75, 0x74, 0x77, 0x76, 0x79, 0x78, 0x01, 0x7a, 0x03, 0x02, 0x59, 0x97, 0x96, 0x99, 0x98, 0xc1, 0xc2, 0xc4, 0x00 },
    { 0x8f, 0x8c, 0x90, 0x91, 0x8e, 0x8d, 0x00 },
};

const uchar CMD_RGB_KEYBORD_Y370_COUNTS[3] = { 0x2f, 0x29, 0x06};

int cmd_active_laptop(usbdevice* kb, usbmode* dummy1, int dummy2, int dummy3, const char* dummy4){
    (void)dummy1;
    (void)dummy2;
    (void)dummy3;
    (void)dummy4;

    if(kb->active)
        return 0;

    uchar cmd[192] = { 0x07, 0xB2, 0x01, 0x00 };
    usbsend(kb, (&(ctrltransfer) { .bRequestType = 0x21, .bRequest = 0x09, .wValue = 0x0307, .wIndex = 0, .wLength = sizeof(cmd), .timeout = 5000, .data = cmd }), 0, 1);
    kb->active = 1;

    return 0;
}

int cmd_idle_laptop(usbdevice* kb, usbmode* dummy1, int dummy2, int dummy3, const char* dummy4){
    (void)dummy1;
    (void)dummy2;
    (void)dummy3;
    (void)dummy4;

    if(!kb->active)
        return 0;

    uchar cmd[192] = { 0x07, 0xB1, 0x01, 0x00 };
    usbsend(kb, (&(ctrltransfer) { .bRequestType = 0x21, .bRequest = 0x09, .wValue = 0x0307, .wIndex = 0, .wLength = sizeof(cmd), .timeout = 5000, .data = cmd }), 0, 1);
    kb->active = 0;

    return 0;
}

static int rgbcmp(const lighting* lhs, const lighting* rhs){
    // Compare two light structures, up until 0xc6 (M key)
    return memcmp(lhs->r, rhs->r, 0xc7) || memcmp(lhs->g, rhs->g, 0xc7) || memcmp(lhs->b, rhs->b, 0xc7);
}

int updatergb_laptop(usbdevice* kb, int force){
    if(!kb->active)
        return 0;
    lighting* lastlight = &kb->profile->lastlight;
    lighting* newlight = &kb->profile->currentmode->light;
    // Don't do anything if the lighting hasn't changed
    if(!force && !lastlight->forceupdate && !newlight->forceupdate
            && !rgbcmp(lastlight, newlight))
        return 0;
    lastlight->forceupdate = newlight->forceupdate = 0;

    // Allocate command buffer
    uchar pkt[192] = { 0x07, CMD_RGB_KEYBORD, 0x00, 0x00 };

    // Set keyboard colors
    for(int i = 0; i < sizeof(CMD_RGB_KEYBORD_COUNTS); i++) {
        // Determine size
        uchar size = CMD_RGB_KEYBORD_COUNTS[i];
        pkt[2] = size;

        // Copy color data
        uchar* pos = pkt + CMD_HEADER_BYTES;
        for(uchar j = 0; j < size; j++) {
            uchar id = CMD_RGB_KEYBORD_IDS[i][j];

            *pos++ = id;
            *pos++ = newlight->r[id];
            *pos++ = newlight->g[id];
            *pos++ = newlight->b[id];
        }

        // Clear remaining color data
        if(i > 0 && size < CMD_TOTAL_ENTRIES)
            memset(pos, 0, (CMD_TOTAL_ENTRIES - size) * CMD_ENTRY_BYTES);

        // Send result to device
        usbsend(kb, (&(ctrltransfer) { .bRequestType = 0x21, .bRequest = 0x09, .wValue = 0x0307, .wIndex = 0, .wLength = sizeof(pkt), .timeout = 5000, .data = pkt }), 0, 1);
    }

    const uchar DEFAULT_ID = 0x69;

    // Set logo colors
    pkt[1] = CMD_RGB_LOGO;
    pkt[2] = CMD_RGB_LOGO_COUNT;

    uchar* pos = pkt + CMD_HEADER_BYTES;
    for (uchar i = 0; i < CMD_RGB_LOGO_COUNT; i++) {
        *pos++ = i + 0x01;

        *pos++ = newlight->r[DEFAULT_ID];
        *pos++ = newlight->g[DEFAULT_ID];
        *pos++ = newlight->b[DEFAULT_ID];
    }

    memset(pos, 0, (CMD_TOTAL_ENTRIES - CMD_RGB_LOGO_COUNT) * CMD_ENTRY_BYTES);
    usbsend(kb, (&(ctrltransfer) { .bRequestType = 0x21, .bRequest = 0x09, .wValue = 0x0307, .wIndex = 0, .wLength = sizeof(pkt), .timeout = 5000, .data = pkt }), 0, 1);

    // Set case colors
    pkt[1] = CMD_RGB_CASE1;
    for (uchar i = 0; i < CMD_RGB_CASE1_COUNT; i++) {
        // Relative position
        uchar r = i % CMD_TOTAL_ENTRIES;

        // Beginning of new command
        if (r == 0) {
            pkt[2] = limit_entries(CMD_RGB_CASE1_COUNT - i);
            pos = pkt + CMD_HEADER_BYTES;
        }

        *pos++ = CMD_RGB_CASE1_IDS[i];

        *pos++ = newlight->r[DEFAULT_ID];
        *pos++ = newlight->g[DEFAULT_ID];
        *pos++ = newlight->b[DEFAULT_ID];

        // Send current command once complete
        if (r == CMD_TOTAL_ENTRIES - 1 || i == CMD_RGB_CASE1_COUNT - 1) {
            memset(pos, 0, (CMD_TOTAL_ENTRIES - r) * CMD_ENTRY_BYTES);
            usbsend(kb, (&(ctrltransfer) { .bRequestType = 0x21, .bRequest = 0x09, .wValue = 0x0307, .wIndex = 0, .wLength = sizeof(pkt), .timeout = 5000, .data = pkt }), 0, 1);
        }
    }

    pkt[1] = CMD_RGB_CASE2;
    for (uchar i = 0; i < CMD_RGB_CASE2_COUNT; i++) {
        // Relative position
        uchar r = i % CMD_TOTAL_ENTRIES;

        // Beginning of new command
        if (r == 0) {
            pkt[2] = limit_entries(CMD_RGB_CASE2_COUNT - i);
            pos = pkt + CMD_HEADER_BYTES;
        }

        *pos++ = CMD_RGB_CASE2_IDS[i];

        *pos++ = newlight->r[DEFAULT_ID];
        *pos++ = newlight->g[DEFAULT_ID];
        *pos++ = newlight->b[DEFAULT_ID];

        // Send current command once complete
        if (r == CMD_TOTAL_ENTRIES - 1 || i == CMD_RGB_CASE2_COUNT - 1) {
            memset(pos, 0, (CMD_TOTAL_ENTRIES - r) * CMD_ENTRY_BYTES);
            usbsend(kb, (&(ctrltransfer) { .bRequestType = 0x21, .bRequest = 0x09, .wValue = 0x0307, .wIndex = 0, .wLength = sizeof(pkt), .timeout = 5000, .data = pkt }), 0, 1);
        }
    }

    memcpy(lastlight, newlight, sizeof(lighting));
    return 0;
}

int start_laptop_kb(usbdevice* kb, int makeactive){
    kb->features = FEAT_RGB;
    kb->layout = LAYOUT_UNKNOWN;

    return 0;
}
